// Test class-to-interface assignment with covariant return types
// This tests that a class method returning a more specific type (Array)
// can satisfy an interface expecting a more general type (Container)


type Container<T> = interface {
    fn slice(end: u64) -> Container<T>
    fn slice(start: u64, end: u64) -> Container<T>
}

type Array<T> = class Container<T> {
    fn slice(end: u64) -> Container<T> {
        return new Array<T>()
    }
    fn slice(start: u64, end: u64) -> Container<T> {
        return new Array<T>()
    }
}

type List<T> = interface Container<T> {
    fn slice(end: u64) -> Container<T>
}
 

// Test valid struct spread field overrides - no type errors

type Serializable = interface {
    fn serialize() -> Serializable
}

type Object = class Serializable {
    fn serialize() = this
}

type Object2 = class {
    fn serialize() = this
}


fn test() {
    let obj1: Serializable = new Object()
    let obj2: Serializable = new Object2()

    let p = {o: obj1, name: "cool"}
    let p2 = {...p, obj: new Object2()}
}