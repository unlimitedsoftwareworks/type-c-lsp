// Test coroutine call validation with incorrect arguments

cfn loop(x: u32[]) -> u32 {
    yield x[0]
    yield x[1]
}

fn main() {
    let co = coroutine loop
    
    /// @Error(TCE023): Coroutine call argument 1 type mismatch
    let x = co([1, 2, 3])  // i32[] instead of u32[]
    
    /// @Error(TCE022): Coroutine call argument count mismatch: Expected 1 argument(s), but got 0
    let y = co()
    
    /// @Error(TCE022): Coroutine call argument count mismatch: Expected 1 argument(s), but got 2
    let z = co([1u32], [2u32])
    
    /// @Error(TCE023): Coroutine call argument 1 type mismatch
    let w = co("string")
}

cfn stringGen(prefix: string, count: u32) -> string {
    yield prefix
}

fn testStrings() {
    let co = coroutine stringGen
    
    /// @Error(TCE023): Coroutine call argument 1 type mismatch
    let a = co(5u32, "hello")
    
    /// @Error(TCE023): Coroutine call argument 1 type mismatch
    let b = co(10u32, 20u32)
    
    /// @Error(TCE022): Coroutine call argument count mismatch
    let c = co("hello")
    
    /// @Error(TCE022): Coroutine call argument count mismatch
    let d = co("hello", 5u32, "extra")
}

cfn simpleGen() -> u32 {
    yield 1u32
}

fn testNoParams() {
    let co = coroutine simpleGen
    
    /// @Error(TCE022): Coroutine call argument count mismatch: Expected 0 argument
    let x = co(42u32)
    
    /// @Error(TCE022): Coroutine call argument count mismatch: Expected 0 argument
    let y = co(1u32, 2u32)
}