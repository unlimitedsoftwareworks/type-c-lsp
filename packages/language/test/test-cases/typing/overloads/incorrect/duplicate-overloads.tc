// Test cases for duplicate function overloads (should fail validation)

// Case 1: Exact duplicate with different return types
// Return type should NOT matter for overload resolution
fn add(a: u32, b: u32) -> u32 {
    return a + b
}

// ERROR: This is a duplicate - same signature as above
fn add(a: u32, b: u32) -> i32 {
    return 0i32
}

// Case 2: Valid overload - different parameter types
fn process(x: u32) -> string {
    return "u32"
}

fn process(x: string) -> string {
    return x
}

// Case 3: Duplicate with void return type
fn log(msg: string) {
    // do something
}

// ERROR: This is a duplicate - return type doesn't matter
fn log(msg: string) -> void {
    // do something else
}

// Case 4: Generic functions cannot be overloaded
fn map<T>(xs: T[]) -> T[] {
    return xs
}

// ERROR: Generic functions cannot be overloaded at all
fn map<T>(xs: T[], f: fn(x: T) -> T) -> T[] {
    let result: T[] = []
    return result
}

// Case 5: Namespace overloads
namespace Utils {
    fn helper(x: u32) -> u32 {
        return x
    }
    
    // ERROR: Duplicate in namespace
    fn helper(x: u32) -> i32 {
        return 0i32
    }
    
    // Valid - different parameter type
    fn helper(x: string) -> string {
        return x
    }
}