// Test cases for struct contextual typing errors

type Point2D = struct {
    x: f32,
    y: f32
}

type Point3D = struct {
    x: f32,
    y: f32,
    z: f32
}

type Color = struct {
    r: u8,
    g: u8,
    b: u8,
    a: u8
}

// ERROR: Missing required field
fn test1() {
    /// @Error(TCE006): Variable 'point' type mismatch
    let point: Point2D = {x: 1.0f}
}

// ERROR: Extra field not in struct
fn test2() {
    let point: Point2D = {x: 1.0f, y: 2.0f, z: 3.0f}
}

// ERROR: Wrong field type
fn test3() {
    /// @Error(TCE006): Variable 'point' type mismatch
    let point: Point2D = {x: "hello", y: 2.0f}
}

// ERROR: Struct spread with incompatible types
fn test4() {
    let base: Point2D = {x: 1.0f, y: 2.0f}
    // @Error(TCE087): Struct spread field type mismatch
    let extended: Point3D = {...base, x: "hello", z: 3.0f}
}

// ERROR: Nested struct field type mismatch
type Entity = struct {
    position: Point2D,
    color: Color
}

fn test5() {
    // ERROR: position.x expects f32 but got i32
    let entity: Entity = {
        position: {x: 10, y: 20.0f},
        color: {r: 255u8, g: 0u8, b: 0u8, a: 255u8}
    }
}

// ERROR: Array of structs with wrong element type
fn test6() {
    // ERROR: Second element has string for x instead of f32
    let points: Point2D[] = [
        {x: 0.0f, y: 0.0f},
        {x: "hello", y: 1.0f}
    ]
}

// ERROR: Struct in function parameter with wrong type
fn transform(point: Point2D) -> Point2D {
    return point
}

fn test7() {
    /// @Error(TCE021): Function call argument 1 type mismatch
    let result = transform({x: "hello", y: 2.0f})
}

// ERROR: Anonymous struct with wrong field count
fn test8() {
    /// @Error(TCE120): Anonymous struct has 3 value
    let point: Point2D = {1.0f, 2.0f, 3.0f}
}

// ERROR: Struct field name mismatch
type Named = struct {
    firstName: string,
    lastName: string
}

fn test9() {
    /// @Error(TCE006): Variable 'person' type mismatch
    let person: Named = {first: "John", lastName: "Doe"}
}

// ERROR: Join type with conflicting field types
type Drawable = struct {
    opacity: f32
}

type Styled = struct {
    opacity: string  // Different type for same field name
}

fn test10() {
    /// @Error(TCE004): Join struct field type conflict: Field 'opacity' has conflicting types
    let obj: Drawable & Styled = {opacity: 1.0f}
}

/// @Error(): Function return type mismatch
fn makeColor(TCE041) -> Color {
    /// @Error(TCE031): Return type mismatch
    return {r: 255u8, g: 0u8, b: 0u8}
}

fn test11() {
    /// @Error(TCE020): Function call argument count mismatch
    let c = makeColor()
}

// ERROR: Lambda returning wrong struct type
fn test12() {
    // ERROR: Lambda returns Point3D but declared as Point2D
    let f: fn() -> Point2D = fn() = {x: 1.0f, y: 2.0f, z: 3.0f}
}

// ERROR: Struct with nullable field mismatch
type NullablePoint = struct {
    x: f32,
    y: f32
}

fn test13() {
    /// @Error(TCE006): Variable 'point' type mismatch
    let point: NullablePoint = {x: "hello", y: 2.0f}
}

// ERROR: Struct in variant with wrong field type
type Result<T, E> = variant {
    Ok(value: T),
    Err(error: E)
}

fn test14() {
    let result: Result<Point2D, string> = Result.Ok({x: 1, y: 2.0f})
}

// ERROR: Multiple struct type errors
fn test15() {
    /// @Error(TCE006): Variable 'point' type mismatch
    let point: Point3D = {x: "hello", y: 2.0f}
}