type vec3 = struct {
    x: f32, y: f32, z: f32
}

type Object3D  = interface {
    fn getPos() -> vec3
    fn getScale() -> vec3
    fn getRotation() -> vec3

    fn getProps() -> (vec3, vec3, vec3)
}

// Test case 1: Duplicate methods with same signature in impl
type Default3DImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    fn getPos() = this.position
    fn getScale() = this.scale
    fn getRotation() = this.rot
    
    /// @Error(TCE066): Duplicate implementation method overload
    fn getPos() = this.position
}

// Test case 2: Valid overloads with different signatures
type AdvancedImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    fn getPos() = this.position
    fn getPos(offset: T) = this.position  // Valid overload - different signature
    fn getScale() = this.scale
    fn getRotation() = this.rot
}

// Test case 3: Generic method cannot be overloaded
type GenericImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    /// @Error(TCE067): Generic implementation method overload error
    fn getPos<U>() -> T = this.position
    fn getPos<V>() -> T = this.position  // Should error - generic methods cannot be overloaded
    fn getScale() = this.scale
    fn getRotation() = this.rot
}

fn main() {
    let x: u32 = 1
}