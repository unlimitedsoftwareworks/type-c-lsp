// Test valid type declarations - should not report any errors

// Different type names in module
type Point = struct { x: u32, y: u32 }
type Vector = struct { x: f32, y: f32, z: f32 }
type Color = u32

// Types with different names in namespace
namespace Math {
    type Vector2D = struct { x: f32, y: f32 }
    type Vector3D = struct { x: f32, y: f32, z: f32 }
    type Matrix = struct { rows: u32, cols: u32 }
}

// Same type name in different scopes is OK
type Data = u32

namespace Scope1 {
    type Data = f32  // OK - different scope
}

namespace Scope2 {
    type Data = string  // OK - different scope
}

// Same name in nested namespaces is OK
namespace Outer {
    type Value = u32
    
    namespace Inner {
        type Value = f32  // OK - different scope
    }
}

// Different types of declarations with unique names
type SimpleType = u32
type StructType = struct { field: u32 }
type UnionType = u32 | f32
type FunctionType = fn(u32) -> u32
type ArrayType = u32[]
type NullableType = u32?

// Generic types with same base name are OK if parameters differ
type Container<T> = struct { value: T }
type Result<T, E> = variant {
    Ok(value: T),
    Error(error: E)
}

// Type aliases with different names
type Int = i32
type UInt = u32
type Float = f32
type String = string