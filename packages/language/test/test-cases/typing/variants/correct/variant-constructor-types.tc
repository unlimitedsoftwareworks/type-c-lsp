// Test variant constructor type annotations
// Testing: Using variant constructor types (e.g., Option.Some) in type annotations

type Option<T> = variant {
    Some(value: T),
    None()
}

type Result<T, E> = variant {
    Ok(value: T),
    Err(error: E)
}

type Status<T> = variant {
    Success(data: T),
    Failure(message: string)
}

// Test 1: Simple variant constructor type without generics
fn testSimpleConstructorType() -> void {
    let noneVal: Option.None<never> = Option.None()
}

// Test 2: Variant constructor type with generics
fn testConstructorTypeWithGenerics() -> void {
    let someVal: Option.Some<u32> = Option.Some(42u32)
    let okVal: Result.Ok<i32, string> = Result.Ok(100i32)
    let errVal: Result.Err<i32, string> = Result.Err("error")
}

// Test 3: More constructor types with different generics
fn testMoreConstructorTypes() -> void {
    let successVal: Status.Success<i32> = Status.Success(200i32)
    let failureVal: Status.Failure<i32> = Status.Failure("failed")
}

// Test 4: Constructor types in function parameters
fn processSome(val: Option.Some<string>) -> string {
    return "processed"
}

fn processOk(result: Result.Ok<u32, string>) -> u32 {
    return 0u32
}

// Test 5: Constructor types in function return types
fn createSome() -> Option.Some<i32> {
    return Option.Some(42)
}

fn createOk() -> Result.Ok<string, i32> {
    return Result.Ok("success")
}

// Test 6: Using constructor types with inference
fn testInference() -> void {
    let s: Option.Some<u32> = Option.Some(10u32)
    let n: Option.None<bool> = Option.None()
}
