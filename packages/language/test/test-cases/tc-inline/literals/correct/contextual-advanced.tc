/**
 * Advanced contextual type inference tests
 * 
 * Tests for newly added contextual typing support:
 * - Lambda parameter type inference
 * - Yield expression contextual typing
 * - Do expression final value typing
 */

// Test 1: Lambda parameter inference from function signature
fn map<T, U>(arr: T[], f: fn(T) -> U) -> U[] {
    let result: U[] = []
    return result
}

fn testLambdaInference() {
    let nums: u32[] = [1, 2, 3]
    // Lambda parameter 'x' should infer as u32 from map's signature
    let doubled = map(nums, fn(x) = x * 2)  // x inferred as u32
}

// Test 2: Lambda with multiple parameters
fn reduce<T, U>(arr: T[], init: U, f: fn(U, T) -> U) -> U {
    return init
}

fn testLambdaMultiParam() {
    let nums: i32[] = [1, 2, 3]
    // Parameters should infer: acc as i32, x as i32
    let sum = reduce(nums, 0, fn(acc, x) = acc + x)
}

// Test 3: Yield expression with contextual type
cfn generator() -> u32 {
    yield 1    // Should infer as u32 from return type
    yield 2    // Should infer as u32 from return type
    yield 3    // Should infer as u32 from return type
}

// Test 4: Yield in coroutine lambda
fn testYieldLambda() {
    let gen: cfn() -> u32 = cfn() -> u32 {
        yield 10   // Should infer as u32
        yield 20   // Should infer as u32
    }
}

// Test 5: Nested lambda inference
fn processArray<T, U>(arr: T[], transform: fn(T) -> U, filter: fn(U) -> bool) -> U[] {
    let result: U[] = []
    return result
}

fn testNestedLambda() {
    let nums: u32[] = [1, 2, 3, 4, 5]
    // First lambda: x inferred as u32, returns f32
    // Second lambda: y inferred as f32, returns bool
    let result = processArray(
        nums,
        fn(x) = x as f32 * 1.5,
        fn(y) = y > 2.0
    )
}

// Test 6: Lambda returning complex types
type Point = {x: f32, y: f32}

fn mapPoints<T>(arr: T[], f: fn(T) -> Point) -> Point[] {
    let result: Point[] = []
    return result
}

fn testLambdaComplexReturn() {
    let nums: u32[] = [1, 2, 3]
    // Lambda parameter 'n' inferred as u32
    // Return type inferred as Point from function signature
    let points = mapPoints(nums, fn(n) = {x: n as f32, y: n as f32})
}

// Test 7: Contextual typing with generics and arrays
fn testGenericArrayContext() -> f32[] {
    // Array elements should infer as f32 from return type
    return [1.0, 2.0, 3.0]
}

// Test 8: Lambda in variable with type annotation
fn testLambdaVariable() {
    let transform: fn(u32) -> f32 = fn(x) = x as f32 * 2.0
    // x should infer as u32 from variable type annotation
}

// Test 9: Yield with tuple types
cfn tupleGenerator() -> (u32, f32) {
    yield (1, 1.0)     // Should infer tuple elements from return type
    yield (2, 2.0)     // Should infer tuple elements from return type
}

// Test 10: Lambda body expression infers from expected return type
fn testLambdaBodyInference() {
    // Lambda body expression should infer u32 from expected function type
    let f: fn(u32) -> u32 = fn(x) = 1       // 1 should infer as u32, not i32
    let g: fn(u32) -> f32 = fn(x) = 3.14    // 3.14 should infer as f32
    let h: fn(u32) -> u32 = fn(x: u32) = 1   // Expression-body: 1 infers as u32
}

// Test 11: Lambda with struct construction
type Config = {timeout: u32, retries: u32}

fn createConfig(f: fn(u32) -> Config) -> Config {
    return f(100)
}

fn testLambdaStructReturn() {
    let cfg = createConfig(fn(base) = {
        timeout: base,      // base inferred as u32
        retries: base / 10  // Should infer operation result as u32
    })
}