// Test file to verify static template validation

// ❌ Error: Static attribute using class template
type BadClass1<T> = class {
    /// @Error(TCE220): cannot use class template parameter(s)
    let static instance: T  // Should error: static cannot use template T
}

// ✅ OK: Non-static attribute can use class template
type GoodClass1<T> = class {
    let instance: T  // OK: non-static can use template
}

// ❌ Error: Static method parameter using class template
type BadClass2<T> = class {
    /// @Error(TCE221): cannot use class template parameter(s)
    static fn process(value: T) -> void { }  // Should error: parameter uses template T
}

// ❌ Error: Static method return type using class template
type BadClass3<T> = class {
    /// @Error(TCE221): cannot use class template parameter(s)
    static fn getInstance() -> T { 
        /// @Error(TCE221): cannot use class template parameter(s)
        return new T()
    }  // Should error: return type uses template T
}

// ✅ OK: Static method with its own generic parameter
type GoodClass2<T> = class {
    static fn get<U>(x: U) -> U = x  // OK: U is method's own generic, not class template
}

// ✅ OK: Instance method can use class template
type GoodClass3<T> = class {
    fn process(value: T) -> T { return value }  // OK: non-static method can use class template
}

// ❌ Error: Complex type using class template in static
type BadClass4<T> = class {
    /// @Error(TCE220): cannot use class template parameter(s)
    let static items: T[]  // Should error: array of template T
}

// ❌ Error: Nested template usage in static
type BadClass5<T> = class {
    /// @Error(TCE220): cannot use class template parameter(s)
    let static wrapper: {value: T}  // Should error: struct with template T
}

// ✅ OK: Static method using its own template with class template in scope
type GoodClass4<T> = class {
    let data: T  // OK: instance member
    static fn convert<U>(froms: U) -> U { return froms }  // OK: U is method's own template
}

// Edge case: Multiple class templates
type BadClass6<A, B> = class {
    /// @Error(TCE221): cannot use class template parameter(s)
    static fn combine(x: A, y: B) -> void { }  // Should error: uses both A and B
}

// Edge case: Nested generics in static method
type BadClass7<T> = class {
    /// @Error(TCE221): cannot use class template parameter(s)
    static fn wrap(mut v: T) -> 
        /// @Error(TCE221): cannot use class template parameter(s)
        { value: T } {
        /// @Error(TCE221): cannot use class template parameter(s)
        let c: T = v

        return {
            value: v
        }
     }  // Should error: return struct contains T
}