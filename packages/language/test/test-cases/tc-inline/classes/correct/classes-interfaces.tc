/**
 * Tests for class and interface type inference
 * - Class types
 * - Class attributes and methods
 * - Generic classes
 * - Interface types
 * - Method calls and member access
 */

// Simple class
type Person = class {
    let name: string
    let age: u32

    fn init(name: string, age: u32) {
        this.name = name
        this.age = age
    }

    fn greet() -> string {
        return "Hello"
    }

    fn getAge() -> u32 {
        return this.age
    }
}

fn testSimpleClass() -> void {
    /// @Type(person): Person
    let person: Person = new Person("Alice", 30)
    /// @Type(personName): string
    let personName = person.name
    /// @Type(personAge): u32
    let personAge = person.age
    /// @Type(greeting): string
    let greeting = person.greet()
    /// @Type(age): u32
    let age = person.getAge()
}

// Generic class
type Box<T> = class {
    let value: T

    fn init(value: T) {
        this.value = value
    }

    fn get() -> T {
        return this.value
    }

    fn set(newValue: T) -> void {
        this.value = newValue
    }
}

fn testGenericClass() -> void {
    /// @Type(intBox): Box<i32>
    let intBox: Box<i32> = new Box<i32>(42)
    /// @Type(boxValue): i32
    let boxValue = intBox.value
    /// @Type(retrieved): i32
    let retrieved = intBox.get()
    
    /// @Type(strBox): Box<string>
    let strBox: Box<string> = new Box<string>("hello")
    /// @Type(strValue): string
    let strValue = strBox.value
    /// @Type(strRetrieved): string
    let strRetrieved = strBox.get()
}

// Class with multiple methods and operator overloading
type Counter = class {
    let count: i32

    fn init(start: i32) {
        this.count = start
    }

    fn increment() -> Counter {
        return this
    }

    fn + (other: Counter) -> Counter {
        return new Counter(this.count)
    }

    fn getCount() -> i32 {
        return this.count
    }
}

fn testClassWithOperators() -> void {
    /// @Type(counter1): Counter
    let counter1: Counter = new Counter(0)
    /// @Type(counter2): Counter
    let counter2: Counter = new Counter(5)
    /// @Type(combined): Counter
    let combined = counter1 + counter2
    /// @Type(finalCount): i32
    let finalCount = combined.getCount()
}

// Interface
type Drawable = interface {
    fn draw(n: Drawable) -> void
    fn move(x: f64, y: f64) -> void
}

// Class implementing interface (structural typing)
type Circle = class Drawable {
    let radius: f64
    let centerX: f64
    let centerY: f64

    fn init(radius: f64, x: f64, y: f64) {
        this.radius = radius
        this.centerX = x
        this.centerY = y
    }

    fn draw(n: Drawable) -> void {
        return
    }

    fn move(x: f64, y: f64) -> void {
        this.centerX = x
        this.centerY = y
    }

    fn getRadius() -> f64 {
        return this.radius
    }

    static fn makeCircle(radius: f64, x: f64, y: f64) -> Circle {
        return new Circle(radius, x, y)
    }
}

fn makeCircle(radius: f64, x: f64, y: f64) -> Circle {
    return new Circle(radius, x, y)
}

fn testInterface() -> void {
    /// @Type(circle): Circle
    let circle: Circle = makeCircle(5.0, 0.0, 0.0)
    /// @Type(drawable): Drawable
    let drawable: Drawable = circle
    /// @Type(radius): f64
    let radius = circle.getRadius()
}

// Nested generic class
type Container<T> = class {
    let items: T[]
    let count: u64

    fn init() {
        this.items = []
        this.count = 0u64
    }

    fn add(item: T) -> void {
        this.count = this.count + 1u64
    }

    fn get(index: u64) -> T {
        return this.items[0u64]
    }
}

fn testNestedGenerics() -> void {
    /// @Type(container): Container<Box<i32>>
    let container: Container<Box<i32> > = new Container<Box<i32> >()
    /// @Type(box1): Box<i32>
    let box1: Box<i32> = new Box<i32>(10)
    /// @Type(retrievedBox): Box<i32>
    let retrievedBox = container.get(0u64)
    /// @Type(innerValue): i32
    let innerValue = retrievedBox.value
}

// Class with generic method return type
type Pair<A, B> = class {
    let first: A
    let second: B

    fn init(first: A, second: B) {
        this.first = first
        this.second = second
    }

    fn getFirst() -> A {
        return this.first
    }

    fn getSecond() -> B {
        return this.second
    }

    fn swap() -> Pair<B, A> {
        return new Pair<B, A>(this.second, this.first)
    }
}

fn testMultipleGenerics() -> void {
    /// @Type(pair): Pair<string, i32>
    let pair: Pair<string, i32> = new Pair<string, i32>("answer", 42)
    /// @Type(firstVal): string
    let firstVal = pair.getFirst()
    /// @Type(secondVal): i32
    let secondVal = pair.getSecond()
    let cat = firstVal + secondVal
    /// @Type(swapped): Pair<i32, string>
    let swapped = pair.swap()
    /// @Type(swappedFirst): i32
    let swappedFirst = swapped.getFirst()
    /// @Type(swappedSecond): string
    let swappedSecond = swapped.getSecond()
}

