type vec3 = struct {
    x: f32, y: f32, z: f32
}

type Object3D  = interface {
    fn getPos() -> vec3
    fn getScale() -> vec3
    fn getRotation() -> vec3
}

type Default3DImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rotation: T
) {
    fn getPos() -> T = this.position
    fn getScale() -> T = this.scale
    fn getRotation() -> T = this.rotation
}

type Mesh = class {
    let pos: vec3
    let scale: vec3
    let rot: vec3

    impl Default3DImpl<vec3>(pos, scale, rot) // Valid: all args are vec3
}

type BadMesh1 = class {
    let pos: vec3
    let scale: vec3
    let rot: vec3

    impl Default3DImpl<vec3>(pos, scale) // Error: Wrong argument count (needs 3, got 2)
}

type BadMesh2 = class {
    let pos: u32  // Wrong type
    let scale: vec3
    let rot: vec3

    impl Default3DImpl<vec3>(pos, scale, rot) // Error: pos is u32, expected vec3
}

fn main() {
    let m: Object3D = new Mesh()
    let z = m.getPos()
}