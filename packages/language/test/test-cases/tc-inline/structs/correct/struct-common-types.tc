/**
 * Tests for common type inference with structural subtyping
 * Type-C allows: largeStruct = smallStruct (extra fields ignored)
 * But common fields must have EXACT matching types
 */

// Valid: All arms have common fields with exact types
/// @Type(getPoint): fn(n: u32) -> struct { x: u32, y: u32 }
fn getPoint(n: u32) {
    return match n {
        0 => {x: 1u32, y: 2u32},
        1 => {x: 3u32, y: 4u32, z: 5u32},
        _ => {x: 6u32, y: 7u32, z: 8u32, w: 9u32}
    }
}

// Valid: All fields present in all arms
/// @Type(getAllFields): fn(n: u32) -> struct { a: u32, b: u32 }
fn getAllFields(n: u32) {
    return match n {
        0 => {a: 1u32, b: 2u32},
        _ => {a: 3u32, b: 4u32}
    }
}

// Valid: Single field common across all arms
/// @Type(getSingleField): fn(n: u32) -> struct { value: u32 }
fn getSingleField(n: u32) {
    return match n {
        0 => {value: 10u32},
        1 => {value: 20u32, extra: 30u32},
        _ => {value: 40u32, extra: 50u32, more: 60u32}
    }
}

fn main() -> void {
    /// @Type(p): struct { x: u32, y: u32 }
    let p = getPoint(0)
    /// @Type(all): struct { a: u32, b: u32 }
    let all = getAllFields(0)
    /// @Type(single): struct { value: u32 }
    let single = getSingleField(0)
}

