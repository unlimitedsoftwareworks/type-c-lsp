// Test cases for variant contextual typing errors

type Result<T, E> = variant {
    Ok(value: T),
    Err(error: E)
}

type Result2 = variant {
    Oks(value: u32),
    Errs(message: string)
}

type Option<T> = variant {
    Some(value: T),
    None
}

// ERROR: Wrong variant type in lambda return
fn processResult<T>(f: fn() -> Result<T, string>) -> Result<T, string> {
    return f()
}

fn test1() {
    /// @Error(TCE041): Lambda return type mismatch
    let f = fn() -> Result<u32, never> = Result2.Oks(42u32)
}

// ERROR: Mismatched generic arguments
fn test2() {
    /// @Error(TCE006): Variable 'f' type mismatch
    let f: fn() -> Result<string, never> = fn() = Result.Ok(42)
}

// ERROR: Wrong constructor for variant
fn test3() {
    // ERROR: Result.Ok returns Ok, but we expect Err
    let err: Result<i32, string> = Result.Ok(42)
}

// ERROR: Array element type mismatch with variants
fn test4() {
    /// @Error(TCE120): Cannot infer common type
    let arr: Result<i32, string>[] = [Result.Ok(1), Result.Ok("hello")]
}

// ERROR: Nested variant type mismatch
fn test5() {
    /// @Error(TCE006): Variable 'nested' type mismatch
    let nested: Result<Result<i32, string>, string> = Result.Ok(Result2.Oks(42u32))
}

// ERROR: Generic constraint violation
fn identity<T>(x: T) -> T {
    return x
}

fn test6() {
    // ERROR: Cannot pass Result<i32, never> where Result<string, bool> is expected
    let r1: Result<i32, never> = Result.Ok(42)
    /// @Error(TCE006): Variable 'r2' type mismatch
    let r2: Result<string, bool> = identity(r1)
}

// ERROR: Variant in wrong function parameter type
fn processOption<T>(opt: Option<T>) -> T {
    return match opt {
        Option.Some(v) => v,
        Option.None => throw "No value"
    }
}


fn test7() {
    // Error: IDK needs fixing
    let value = processOption(Result.Ok<u32,string>(42))
}

// ERROR: Lambda return type doesn't match variant
fn test8() {
    /// @Error(TCE006): Variable 'f' type mismatch
    let f: fn() -> Result<i32, string> = fn() = 42
}

// ERROR: Variant with incompatible struct field
type Point = struct {
    x: i32,
    y: i32
}

fn test9() {
    /// @Error(Variable 'opt' type mismatch): Variable 'opt' type mismatch
    let opt: Option<Point> = Option.Some({x: 1.0f, y: 2.0f})
}

// ERROR: Multiple variant type errors in single expression
fn test10() {
    /// @Error(Variable 'f' type mismatch): Variable 'opt' type mismatch
    let f: fn() -> Result<u32, bool> = fn() -> Result<i32, string> = Result2.Oks(42u32)
}