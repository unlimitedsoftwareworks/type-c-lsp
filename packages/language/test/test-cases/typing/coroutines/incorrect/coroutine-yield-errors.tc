// Test coroutine yield type errors

// ❌ Coroutine with mismatched yield types
cfn mismatchedYields() {
    yield 1
    yield "oops"  // Error: cannot infer common type
}

// ❌ Coroutine with explicit type not matching yields
cfn wrongExplicitType() -> string {
    yield 1  // Error: expected string but got i32
    yield 2
}

// ❌ Coroutine yielding different numeric types (should infer but may fail)
cfn mixedNumericYields() -> u32 {
    yield 1u32
    yield 2.5  // Error: expected u32 but got f64
}

// ❌ Regular function using yield
fn regularWithYield() {
    yield 1  // Error: yield can only be used in coroutines
}

// ❌ Coroutine using return
cfn coroutineWithReturn() {
    return 1  // Error: coroutines must use yield instead of return
}

// ❌ Void yield type but yielding values
cfn voidYieldingValue() -> void {
    yield 42  // Error: coroutine must yield void
}

// ❌ Non-void yield type but yielding nothing
cfn missingYieldValue() -> u32 {
    yield  // Error: coroutine must yield a value of type u32
}

// ❌ Struct with incompatible fields
cfn incompatibleStructs() {
    yield {x: 1u32, y: 2u32}
    yield {x: "oops", y: 4u32}  // Error: field x has different types
}

// ❌ Declared type doesn't match inferred
cfn wrongDeclaredType() -> string {
    yield 1u32
    yield 2u32
}  // Error: declared string but inferred u32