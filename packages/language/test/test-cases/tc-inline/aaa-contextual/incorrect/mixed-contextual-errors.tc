// Mixed contextual typing error test cases
// Complex scenarios combining multiple type system features

type Result<T, E> = variant {
    Ok(value: T),
    Err(error: E)
}

type Result2 = variant {
    Oks(value: u32),
    Errs(error: string)
}

type Option<T> = variant {
    Some(value: T),
    None
}

type Point = struct {
    x: f32,
    y: f32
}

type Point3D = struct {
    x: f32,
    y: f32,
    z: f32
}

// ERROR: Array of variants with wrong lambda return type
fn test1() {
    // ERROR: Lambda returns Result2 but array expects Result
    let arr: Result<i32, string>[] = >>[
        Result.Ok(1),
        fn() -> Result<i32, string> = Result2.Oks(42u32)
    ]<<
}

// ERROR: Lambda returning struct with wrong fields in variant
fn test2() {
    // ERROR: Point3D has extra field 'z' that Point doesn't have
    let f: fn() -> Result<Point, string> = >>fn() = Result.Ok({x: 1.0f, y: 2.0f, z: 3.0f})<<
}

// ERROR: Higher-order function with incompatible types
fn mapResult<T, U, E>(r: Result<T, E>, f: fn(a: T) -> U) -> Result<U, E> {
    return match r {
        Result.Ok(v) => Result.Ok(f(v)),
        Result.Err(e) => Result.Err(e)
    }
}

fn test3() {
    let r: Result<Point, string> = Result.Ok({x: 1.0f, y: 2.0f})
    // ERROR: Lambda changes Point to string but Result expects Point
    let scaled = >>mapResult(r, fn(p: Point) = "invalid")<<
}

// ERROR: Array of lambdas with mismatched return variants
fn test4() {
    // ERROR: Second lambda returns Result2 instead of Result
    let operations: fn() -> Result<i32, string>[] = >>[
        fn() = Result.Ok(1),
        fn() = Result2.Oks(2u32)
    ]<<
}

// ERROR: Nested structures with type mismatch
type Entity = struct {
    position: Point,
    health: i32
}

fn test5() {
    // ERROR: Position has wrong type (i32 instead of f32)
    let entities: Result<Entity[], string> = >>Result.Ok([
        {
            position: {x: 1, y: 2},
            health: 100
        }
    ])<<
}

// ERROR: Lambda chain with incompatible variant types
fn test6() {
    // ERROR: Returns Result2 but declared as Result
    let process: fn(a: Point) -> Result<Point, string> = >>fn(p) = Result2.Oks(42u32)<<
}

// ERROR: Array of tuples with wrong variant types
fn test7() {
    // ERROR: First tuple has Result2 instead of Result
    let pairs: (Result<i32, string>, Option<u32>)[] = >>[
        (Result2.Oks(1u32), Option.Some(2u32)),
        (Result.Err("error"), Option.None)
    ]<<
}

// ERROR: Generic function with type parameter mismatch
fn flatMap<T, U, E>(r: Result<T, E>, f: fn(a: T) -> Result<U, E>) -> Result<U, E> {
    return match r {
        Result.Ok(v) => f(v),
        Result.Err(e) => Result.Err(e)
    }
}

fn test8() {
    let r: Result<i32, string> = Result.Ok(42)
    // ERROR: Lambda returns Result<string, bool> but expected Result<U, string>
    let result = >>flatMap(r, fn(x: i32) -> Result<string, bool> = Result.Err(true))<<
}

// ERROR: Complex match with incompatible return types
fn test9() {
    let value: Result<Point[], string> = Result.Ok([{x: 1.0f, y: 2.0f}])
    // ERROR: Err branch returns Result2 instead of Result
    let processed = match value {
        Result.Ok(points) => Result.Ok(points),
        Result.Err(e) => >>Result2.Errs(e)<<
    }
}

// ERROR: Lambda returning array with wrong variant type in struct
type Container = struct {
    items: Result<i32, string>[]
}

fn test10() {
    // ERROR: Array contains Result2 instead of Result
    let make: fn() -> Container = >>fn() = {
        items: [Result.Ok(1), Result2.Oks(2u32)]
    }<<
}

// ERROR: Captured variant with wrong type
fn test11() {
    let default: Result<i32, string> = Result.Ok(0)
    // ERROR: Returns Result2 instead of Result
    let getOrDefault = fn(opt: Option<i32>) = match opt {
        Option.Some(v) => Result.Ok(v),
        Option.None => >>Result2.Oks(0u32)<<
    }
}

// ERROR: Nested lambdas with struct field type mismatch
fn test12() {
    // ERROR: Inner lambda returns Point3D but declared as Point
    let f: fn(a: Point) -> fn() -> Result<Point, string> = >>fn(p) = fn() = Result.Ok({x: p.x, y: p.y, z: 1.0f})<<
}

// ERROR: Array with mixed correct and incorrect variants
fn test13() {
    // ERROR: Second element uses Result2
    let wrapped: Result<Point, string>[] = >>[
        Result.Ok({x: 1.0f, y: 2.0f}),
        Result2.Oks(42u32)
    ]<<
}

// ERROR: Complex tuple with wrong types
fn test14() {
    // ERROR: First element uses Result2, second lambda has wrong return type
    let complex: (
        Result<Point[], string>,
        fn(a: i32) -> Option<i32>
    ) = >>(
        Result2.Oks(42u32),
        fn(x) = Option.Some("hello")
    )<<
}

// ERROR: Lambda with explicit wrong return annotation matching wrong variant
fn test15() {
    // ERROR: Declares Result but returns Result2
    let f = >>fn() -> Result<u32, never> = Result2.Oks(42u32)<<
}

// ERROR: Struct field expects Result but gets Result2
type Wrapper = struct {
    result: Result<i32, string>
}

fn test16() {
    // ERROR: Field 'result' expects Result but got Result2
    let w: Wrapper = >>{
        result: Result2.Oks(42u32)
    }<<
}

// ERROR: Higher-order function composing incompatible types
fn compose<A, B, C>(f: fn(a: B) -> C, g: fn(a: A) -> B) -> fn(a: A) -> C {
    return fn(x) = f(g(x))
}

fn test17() {
    // ERROR: g returns Result2 but f expects Result
    let combined = >>compose(
        fn(r: Result<i32, string>) = r,
        fn(x: i32) -> Result2 = Result2.Oks(x as u32)
    )<<
}

// ERROR: Multiple nested errors with variants and structs
fn test18() {
    // ERROR: Multiple issues - Result2 instead of Result, Point3D instead of Point
    let complex: Result<Point[], string> = >>Result2.Oks([
        {x: 1.0f, y: 2.0f, z: 3.0f}
    ])<<
}