// Comprehensive mixed contextual typing test cases
// Combines variants, lambdas, structs, arrays, and more

type Result<T, E> = variant {
    Ok(value: T),
    Err(error: E)
}

type Option<T> = variant {
    Some(value: T),
    None
}

type Point = struct {
    x: f32,
    y: f32
}

// Test 7: Array of tuples with variants
fn test7() {
    let pairs: {x: Result<i32, string>, y: Option<u32>}[] = [
        {Result.Ok(1), Option.Some(2u32)},
        {Result.Err("error"), Option.None()}
    ]
}

// Test 8: Generic function with multiple constraints
fn flatMap<T, U, E>(r: Result<T, E>, f: fn(a: T) -> Result<U, E>) -> Result<U, E> {
    return match r {
        Result.Ok(v) => f(v),
        Result.Err(e) => Result.Err(e)
    }
}

// Test 12: Lambda with captured variant
fn test12() {
    let default: Result<i32, string> = Result.Ok(0)
    let getOrDefault = fn(opt: Option<i32>) = match opt {
        Option.Some(v) => Result.Ok(v),
        Option.None => default
    }
}

// Test 13: Nested lambdas with structs and variants
fn test13() {
    let f: fn(a: Point) -> fn() -> Result<Point, string> = fn(p) = fn() = Result.Ok(p)
}

// Test 14: Array comprehension style with mixed types
fn test14() {
    let points: Point[] = [{x: 1.0f, y: 2.0f}]
    let wrapped: Result<Point, string>[] = [Result.Ok({x: 1.0f, y: 2.0f})]
}

// Test 15: Complex tuple with everything
fn test15() {
    let complex: (
        Result<Point[], string>,
        fn(a: i32) -> Option<i32>,
        Entity[]
    ) = (
        Result.Ok([{x: 1.0f, y: 2.0f}]),
        fn(x) = Option.Some(x),
        []
    )
}