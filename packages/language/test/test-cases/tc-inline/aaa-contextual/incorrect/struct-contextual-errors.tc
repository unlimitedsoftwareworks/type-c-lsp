// Test cases for struct contextual typing errors

type Point2D = struct {
    x: f32,
    y: f32
}

type Point3D = struct {
    x: f32,
    y: f32,
    z: f32
}

type Color = struct {
    r: u8,
    g: u8,
    b: u8,
    a: u8
}

// ERROR: Missing required field
fn test1() {
    // ERROR: Missing field 'y'
    let point: Point2D = >>{x: 1.0f}<<
}

// ERROR: Extra field not in struct
fn test2() {
    // ERROR: Field 'z' not in Point2D
    let point: Point2D = >>{x: 1.0f, y: 2.0f, z: 3.0f}<<
}

// ERROR: Wrong field type
fn test3() {
    // ERROR: Field 'x' expects f32 but got string
    let point: Point2D = >>{x: "hello", y: 2.0f}<<
}

// ERROR: Struct spread with incompatible types
fn test4() {
    let base: Point2D = {x: 1.0f, y: 2.0f}
    // ERROR: Cannot override 'x' with string
    let extended: Point3D = >>{...base, x: "hello", z: 3.0f}<<
}

// ERROR: Nested struct field type mismatch
type Entity = struct {
    position: Point2D,
    color: Color
}

fn test5() {
    // ERROR: position.x expects f32 but got i32
    let entity: Entity = >>{
        position: {x: 10, y: 20.0f},
        color: {r: 255u8, g: 0u8, b: 0u8, a: 255u8}
    }<<
}

// ERROR: Array of structs with wrong element type
fn test6() {
    // ERROR: Second element has string for x instead of f32
    let points: Point2D[] = >>[
        {x: 0.0f, y: 0.0f},
        {x: "hello", y: 1.0f}
    ]<<
}

// ERROR: Struct in function parameter with wrong type
fn transform(point: Point2D) -> Point2D {
    return point
}

fn test7() {
    // ERROR: Argument has string field instead of f32
    let result = >>transform({x: "hello", y: 2.0f})<<
}

// ERROR: Anonymous struct with wrong field count
fn test8() {
    // ERROR: Anonymous struct has 3 values but Point2D has 2 fields
    let point: Point2D = >>{1.0f, 2.0f, 3.0f}<<
}

// ERROR: Struct field name mismatch
type Named = struct {
    firstName: string,
    lastName: string
}

fn test9() {
    // ERROR: Field 'first' doesn't exist, should be 'firstName'
    let person: Named = >>{first: "John", lastName: "Doe"}<<
}

// ERROR: Join type with conflicting field types
type Drawable = struct {
    opacity: f32
}

type Styled = struct {
    opacity: string  // Different type for same field name
}

fn test10() {
    // ERROR: Field 'opacity' has conflicting types (f32 vs string)
    let obj: Drawable & Styled = >>{opacity: 1.0f}<<
}

// ERROR: Struct return type mismatch
fn makeColor() -> Color {
    // ERROR: Missing field 'a'
    return >>{r: 255u8, g: 0u8, b: 0u8}<<
}

fn test11() {
    let c = makeColor()
}

// ERROR: Lambda returning wrong struct type
fn test12() {
    // ERROR: Lambda returns Point3D but declared as Point2D
    let f: fn() -> Point2D = >>fn() = {x: 1.0f, y: 2.0f, z: 3.0f}<<
}

// ERROR: Struct with nullable field mismatch
type NullablePoint = struct {
    x: f32?,
    y: f32?
}

fn test13() {
    // ERROR: Field 'x' expects f32? but got string
    let point: NullablePoint = >>{x: "hello", y: 2.0f}<<
}

// ERROR: Struct in variant with wrong field type
type Result<T, E> = variant {
    Ok(value: T),
    Err(error: E)
}

fn test14() {
    // ERROR: Point2D.x expects f32 but got i32
    let result: Result<Point2D, string> = >>Result.Ok({x: 1, y: 2.0f})<<
}

// ERROR: Multiple struct type errors
fn test15() {
    // ERROR: Multiple issues - wrong type for x, missing field z
    let point: Point3D = >>{x: "hello", y: 2.0f}<<
}