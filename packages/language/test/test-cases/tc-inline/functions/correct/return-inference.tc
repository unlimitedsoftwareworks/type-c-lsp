/**
 * Tests for return type inference
 * - Expression-body functions
 * - Block-body functions with return statements
 * - Recursive functions with base cases
 * - Nested functions (ensure we don't collect inner returns)
 */

// Simple expression-body function
/// @Type(f3): fn() -> u32
fn f3() = 3u32

// Recursive expression-body with match (has base cases)
/// @Type(anotherFib): fn(n: u32) -> u32
fn anotherFib(n: u32) =
	match n {
		0 => 0u32,
		1 => 1u32,
		_ => anotherFib(n - 1) + anotherFib(n - 2),
	}

// Recursive block-body with return statements
/// @Type(fiiib): fn(n: u32) -> u32
fn fiiib(n: u32) {
	if n < 2 {
		return 0u32
	}
	return fiiib(n - 1) + fiiib(n - 2)
}

// Nested function test - ensure we don't collect inner function's returns
/// @Type(outerFunc): fn(x: u32) -> u32
fn outerFunc(x: u32) {
	// Inner function with its own return
	fn innerFunc(y: u32) {
		return y + 1u32
	}
	
	// Outer function's return
	return x + innerFunc(5)
}

fn main() -> void {
	/// @Type(a): u32
	let a = f3()
	/// @Type(b): u32
	let b = anotherFib(10)
	/// @Type(c): u32
	let c = fiiib(10)
	/// @Type(d): u32
	let d = outerFunc(5)
}

