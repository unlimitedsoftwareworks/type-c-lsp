type vec3 = struct {
    x: f32, y: f32, z: f32
}

type Object3D = interface {
    fn getPos() -> vec3
    fn getScale() -> vec3
    fn getRotation() -> vec3
    fn randomFn() -> vec3
}

// Test case: Impl extending an interface
// The impl provides concrete implementations for some interface methods
// and should have access to the interface methods it doesn't override
type Default3DImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    // These methods shadow the interface methods with the same signature
    fn getPos() = this.position
    fn getScale() = this.scale
    fn getRotation() = this.rot
    
    // This method should have access to the interface method randomFn()
    fn useRandomFn() -> vec3 {
        return this.randomFn()
    }
    
    // This method should have access to its own methods
    fn getAllPositions() -> vec3 {
        let p = this.getPos()
        let s = this.getScale()
        let r = this.getRotation()
        return p
    }
}

// Test with a class using the impl
type MyObject = class {
    let obj: Default3DImpl<vec3>
    
    fn init(pos: vec3) {
        // This should work - accessing impl methods
        let p = this.obj.getPos()
        let s = this.obj.getScale()
        
        // This should work - accessing non-shadowed interface method
        let rand = this.obj.randomFn()
    }
}