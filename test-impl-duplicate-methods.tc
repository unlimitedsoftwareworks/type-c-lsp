type vec3 = struct {
    x: f32, y: f32, z: f32
}

type Object3D  = interface {
    fn getPos() -> vec3
    fn getScale() -> vec3
    fn getRotation() -> vec3
}

// Test case 1: Duplicate methods with same signature in impl
type Default3DImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    fn getPos() = this.position
    fn getScale() = this.scale
    fn getRotation() = this.rot
    
    // This should trigger an error - duplicate method signature
    fn getPos() = this.position
}

// Test case 2: Valid overloads with different signatures
type AdvancedImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    fn getPos() = this.position
    fn getPos(offset: T) = this.position  // Valid overload - different signature
    fn getScale() = this.scale
    fn getRotation() = this.rot
}

// Test case 3: Generic method cannot be overloaded
type GenericImpl<T> = impl Object3D (
    position: T,
    scale: T,
    rot: T
) {
    fn getPos<U>() -> vec3 = this.position
    fn getPos<V>() -> vec3 = this.position  // Should error - generic methods cannot be overloaded
    fn getScale() = this.scale
    fn getRotation() = this.rot
}

fn main() {
    let x: u32 = 1
}